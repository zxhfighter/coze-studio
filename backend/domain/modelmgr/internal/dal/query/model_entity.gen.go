// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/coze-dev/coze-studio/backend/domain/modelmgr/internal/dal/model"
)

func newModelEntity(db *gorm.DB, opts ...gen.DOOption) modelEntity {
	_modelEntity := modelEntity{}

	_modelEntity.modelEntityDo.UseDB(db, opts...)
	_modelEntity.modelEntityDo.UseModel(&model.ModelEntity{})

	tableName := _modelEntity.modelEntityDo.TableName()
	_modelEntity.ALL = field.NewAsterisk(tableName)
	_modelEntity.ID = field.NewInt64(tableName, "id")
	_modelEntity.MetaID = field.NewInt64(tableName, "meta_id")
	_modelEntity.Name = field.NewString(tableName, "name")
	_modelEntity.Description = field.NewString(tableName, "description")
	_modelEntity.DefaultParams = field.NewField(tableName, "default_params")
	_modelEntity.Scenario = field.NewField(tableName, "scenario")
	_modelEntity.Status = field.NewField(tableName, "status")
	_modelEntity.CreatedAt = field.NewInt64(tableName, "created_at")
	_modelEntity.UpdatedAt = field.NewInt64(tableName, "updated_at")
	_modelEntity.DeletedAt = field.NewField(tableName, "deleted_at")

	_modelEntity.fillFieldMap()

	return _modelEntity
}

// modelEntity 模型信息
type modelEntity struct {
	modelEntityDo

	ALL           field.Asterisk
	ID            field.Int64  // 主键ID
	MetaID        field.Int64  // 模型元信息 id
	Name          field.String // 名称
	Description   field.String // 描述
	DefaultParams field.Field  // 默认参数
	Scenario      field.Field  // 模型应用场景
	Status        field.Field  // 模型状态
	CreatedAt     field.Int64  // Create Time in Milliseconds
	UpdatedAt     field.Int64  // Update Time in Milliseconds
	DeletedAt     field.Field  // Delete Time in Milliseconds

	fieldMap map[string]field.Expr
}

func (m modelEntity) Table(newTableName string) *modelEntity {
	m.modelEntityDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m modelEntity) As(alias string) *modelEntity {
	m.modelEntityDo.DO = *(m.modelEntityDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *modelEntity) updateTableName(table string) *modelEntity {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt64(table, "id")
	m.MetaID = field.NewInt64(table, "meta_id")
	m.Name = field.NewString(table, "name")
	m.Description = field.NewString(table, "description")
	m.DefaultParams = field.NewField(table, "default_params")
	m.Scenario = field.NewField(table, "scenario")
	m.Status = field.NewField(table, "status")
	m.CreatedAt = field.NewInt64(table, "created_at")
	m.UpdatedAt = field.NewInt64(table, "updated_at")
	m.DeletedAt = field.NewField(table, "deleted_at")

	m.fillFieldMap()

	return m
}

func (m *modelEntity) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *modelEntity) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 10)
	m.fieldMap["id"] = m.ID
	m.fieldMap["meta_id"] = m.MetaID
	m.fieldMap["name"] = m.Name
	m.fieldMap["description"] = m.Description
	m.fieldMap["default_params"] = m.DefaultParams
	m.fieldMap["scenario"] = m.Scenario
	m.fieldMap["status"] = m.Status
	m.fieldMap["created_at"] = m.CreatedAt
	m.fieldMap["updated_at"] = m.UpdatedAt
	m.fieldMap["deleted_at"] = m.DeletedAt
}

func (m modelEntity) clone(db *gorm.DB) modelEntity {
	m.modelEntityDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m modelEntity) replaceDB(db *gorm.DB) modelEntity {
	m.modelEntityDo.ReplaceDB(db)
	return m
}

type modelEntityDo struct{ gen.DO }

type IModelEntityDo interface {
	gen.SubQuery
	Debug() IModelEntityDo
	WithContext(ctx context.Context) IModelEntityDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IModelEntityDo
	WriteDB() IModelEntityDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IModelEntityDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IModelEntityDo
	Not(conds ...gen.Condition) IModelEntityDo
	Or(conds ...gen.Condition) IModelEntityDo
	Select(conds ...field.Expr) IModelEntityDo
	Where(conds ...gen.Condition) IModelEntityDo
	Order(conds ...field.Expr) IModelEntityDo
	Distinct(cols ...field.Expr) IModelEntityDo
	Omit(cols ...field.Expr) IModelEntityDo
	Join(table schema.Tabler, on ...field.Expr) IModelEntityDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IModelEntityDo
	RightJoin(table schema.Tabler, on ...field.Expr) IModelEntityDo
	Group(cols ...field.Expr) IModelEntityDo
	Having(conds ...gen.Condition) IModelEntityDo
	Limit(limit int) IModelEntityDo
	Offset(offset int) IModelEntityDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IModelEntityDo
	Unscoped() IModelEntityDo
	Create(values ...*model.ModelEntity) error
	CreateInBatches(values []*model.ModelEntity, batchSize int) error
	Save(values ...*model.ModelEntity) error
	First() (*model.ModelEntity, error)
	Take() (*model.ModelEntity, error)
	Last() (*model.ModelEntity, error)
	Find() ([]*model.ModelEntity, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ModelEntity, err error)
	FindInBatches(result *[]*model.ModelEntity, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ModelEntity) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IModelEntityDo
	Assign(attrs ...field.AssignExpr) IModelEntityDo
	Joins(fields ...field.RelationField) IModelEntityDo
	Preload(fields ...field.RelationField) IModelEntityDo
	FirstOrInit() (*model.ModelEntity, error)
	FirstOrCreate() (*model.ModelEntity, error)
	FindByPage(offset int, limit int) (result []*model.ModelEntity, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IModelEntityDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m modelEntityDo) Debug() IModelEntityDo {
	return m.withDO(m.DO.Debug())
}

func (m modelEntityDo) WithContext(ctx context.Context) IModelEntityDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m modelEntityDo) ReadDB() IModelEntityDo {
	return m.Clauses(dbresolver.Read)
}

func (m modelEntityDo) WriteDB() IModelEntityDo {
	return m.Clauses(dbresolver.Write)
}

func (m modelEntityDo) Session(config *gorm.Session) IModelEntityDo {
	return m.withDO(m.DO.Session(config))
}

func (m modelEntityDo) Clauses(conds ...clause.Expression) IModelEntityDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m modelEntityDo) Returning(value interface{}, columns ...string) IModelEntityDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m modelEntityDo) Not(conds ...gen.Condition) IModelEntityDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m modelEntityDo) Or(conds ...gen.Condition) IModelEntityDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m modelEntityDo) Select(conds ...field.Expr) IModelEntityDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m modelEntityDo) Where(conds ...gen.Condition) IModelEntityDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m modelEntityDo) Order(conds ...field.Expr) IModelEntityDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m modelEntityDo) Distinct(cols ...field.Expr) IModelEntityDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m modelEntityDo) Omit(cols ...field.Expr) IModelEntityDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m modelEntityDo) Join(table schema.Tabler, on ...field.Expr) IModelEntityDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m modelEntityDo) LeftJoin(table schema.Tabler, on ...field.Expr) IModelEntityDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m modelEntityDo) RightJoin(table schema.Tabler, on ...field.Expr) IModelEntityDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m modelEntityDo) Group(cols ...field.Expr) IModelEntityDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m modelEntityDo) Having(conds ...gen.Condition) IModelEntityDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m modelEntityDo) Limit(limit int) IModelEntityDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m modelEntityDo) Offset(offset int) IModelEntityDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m modelEntityDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IModelEntityDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m modelEntityDo) Unscoped() IModelEntityDo {
	return m.withDO(m.DO.Unscoped())
}

func (m modelEntityDo) Create(values ...*model.ModelEntity) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m modelEntityDo) CreateInBatches(values []*model.ModelEntity, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m modelEntityDo) Save(values ...*model.ModelEntity) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m modelEntityDo) First() (*model.ModelEntity, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelEntity), nil
	}
}

func (m modelEntityDo) Take() (*model.ModelEntity, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelEntity), nil
	}
}

func (m modelEntityDo) Last() (*model.ModelEntity, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelEntity), nil
	}
}

func (m modelEntityDo) Find() ([]*model.ModelEntity, error) {
	result, err := m.DO.Find()
	return result.([]*model.ModelEntity), err
}

func (m modelEntityDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ModelEntity, err error) {
	buf := make([]*model.ModelEntity, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m modelEntityDo) FindInBatches(result *[]*model.ModelEntity, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m modelEntityDo) Attrs(attrs ...field.AssignExpr) IModelEntityDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m modelEntityDo) Assign(attrs ...field.AssignExpr) IModelEntityDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m modelEntityDo) Joins(fields ...field.RelationField) IModelEntityDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m modelEntityDo) Preload(fields ...field.RelationField) IModelEntityDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m modelEntityDo) FirstOrInit() (*model.ModelEntity, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelEntity), nil
	}
}

func (m modelEntityDo) FirstOrCreate() (*model.ModelEntity, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelEntity), nil
	}
}

func (m modelEntityDo) FindByPage(offset int, limit int) (result []*model.ModelEntity, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m modelEntityDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m modelEntityDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m modelEntityDo) Delete(models ...*model.ModelEntity) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *modelEntityDo) withDO(do gen.Dao) *modelEntityDo {
	m.DO = *do.(*gen.DO)
	return m
}
